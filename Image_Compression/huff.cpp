//
//  huff.cpp
//  CS6015-PBM Image Compression
//
//  Created by Irene Yeung on 1/31/18.
//  Copyright Â© 2018 Irene Yeung. All rights reserved.
//
#include "pbmcompress-v1.h"
#include "huff.h"

#include <stdio.h>
#include <tuple>
#include <vector>
#include <string>
#include <iostream>
#include <bitset>
#include <cassert>


/* Huffman Encoding Specifications:
 -Encoding is performed using predefined lookup table via regehr (ie huff.h)
 -Binary strings in huffman lookup table are read left to right
 -Bytes are added to vector little endian (ie B0, B1, B2, B3).
 -Bits in bytes are filled in from right to left (ie most significant bits of
 byte are added first -- BIG ENDIAN).
 -Note: lookup table is not optimized for all input files. Some files may not
 be compressed significantly (or at all) since a generalized lookup table is used.
 */





std::string byteLookup(uint8_t byte); //Uses huff.h lookup table for binary string
uint8_t binStrtoByte(std::string binstr); //Converts an 8 bit long binary string to a single byte
std::vector<uint8_t> * huffEncode(std::vector<uint8_t> * rledata);
std::tuple<bool, int, int, std::vector<uint8_t> *> huff(std::string filename); //Driver method
void testHuff(); //Tests huffman compression on a randomly generated byte vector
void printBits(std::vector<uint8_t> bytearr);



/*
 Prints bits of byte array to std::cout -
 bytes are printed little endian order,
 bits are big endian.
 */
void printBits(std::vector<uint8_t> bytearr){
    for (int i = 0; i < bytearr.size(); i++) {
        std::bitset<8> bits;
        bits = bytearr[i];
        std::cout << bits << " ";
    }
    std::cout << std::endl;
}

/*
 Uses pregenerated huff.h lookup table to convert a given byte value to a
 binary string.
 */
std::string byteLookup(uint8_t byte) {
    return huff_table[byte];
}

/*
 Converts a binary string of 8 bits in length to a byte.
 Fills in bits of binary string from LEFT to RIGHT -
 i.e., first bit of string is in msb bit, final bit of string is in lsb bit.
 */
uint8_t binStrtoByte(std::string binstr) {
    assert(binstr.size() == 8);
    uint8_t byteval = 0x0;
    uint8_t j = binstr.size() - 1; //tracks which bit of byte that is being filled
    for (int i = 0; i < binstr.size(); i++, j--) {
        if (binstr[i] == '1'){ //check if bit is set in binary string
            byteval |=  1 << j ; //set bit in byte, leftmost bit in string (i= 0) goes in leftmost spot of byte
        }
    }
    return byteval;
}

/* Uses Huffman compression to compress a vector of bytes generated
 from the run-length compression encoding output.
 */

std::vector<uint8_t> * huffEncode(std::vector<uint8_t> * rledata){
    const uint8_t FILLED_BYTE = 8;
    std::vector<uint8_t>* huffdata = new std::vector<uint8_t>;
    std::string currbits; //store current bits waiting to be converted to next byte
    for (uint8_t byte: *rledata) {
        currbits += byteLookup(byte); //Reads in binary strings LEFT to RIGHT
        if (currbits.size() < FILLED_BYTE) {
            continue;
        }
        else if (currbits.size() >= FILLED_BYTE) { // if >= 8 bits long, process to bytes
            while (currbits.size() >= FILLED_BYTE){ //Repeat until <8 bits are left
                std::string nextbyte = currbits.substr(0, FILLED_BYTE); //Next byte will be first 8 bits of string
                huffdata->push_back(binStrtoByte(nextbyte));
                currbits = currbits.substr(8); //Update currbits
                //If currbits is exactly 8 bits long, currbits becomes empty string
            }
        }
    }
    //Check for remainder bits - pad any leftover bits with 0's going right
    //(ie fill LSBs not MSBs with 0)
    if (currbits.size() > 0){
        while (currbits.size() < FILLED_BYTE){
            currbits += "0";
        }
        huffdata->push_back(binStrtoByte(currbits)); //Add padded byte to end
    }
    return huffdata;
}

/*
 Driver method that checks pbm file format and processes huffman compression.
 */
std::tuple<bool, int, int, std::vector<uint8_t> *> huff(std::string filename){
    std::tuple<bool, int, int, std::vector<uint8_t> *> runlength = rle(filename);
    if (!std::get<0>(runlength)){ //i.e., pbm file or other failure
        return std::make_tuple(false, 0, 0, (std::vector<uint8_t> *) 0);
    }
    auto dimensions = std::make_pair(std::get<1>(runlength), std::get<2>(runlength));
    std::vector<uint8_t> * huff = huffEncode(std::get<3>(runlength));
    delete(std::get<3>(runlength));
    return std::make_tuple(true, dimensions.first, dimensions.second, huff);
    //huff needs to be freed in main
}

